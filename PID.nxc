#define motor_direito OUT_A
#define motor_esquerdo OUT_C
#define ambos_motores OUT_AC
#define maximo_integrador 10   // Valor máximo para o estado integrativo
#define minimo_integrador -10  // Valor mínimo para o estado integrativo
#define potencia_inicial 70     // Valor de potencia inicial passada para o motor
#define kp 1  // Ganho proporcional
#define ki 0  // Ganho integrativo
#define kd 0   // Ganho derivativo
#define Ultra_chao_direito IN_1
#define Ultra_chao_esquerdo IN_4
#define Ultra_boneco_direito IN_2
#define Ultra_boneco_esquerdo IN_3

task main (){

      float rotacao_esquerda, rotacao_direita, correcao, erro_tragetoria, historico_erro = 0, ultimo_erro = 0;
      float termo_proporcional = 0, termo_integrativo = 0, termo_derivativo = 0;

      SetSensorLowspeed(Ultra_boneco_direito);
      SetSensorLowspeed(Ultra_boneco_esquerdo);
      OnFwd(ambos_motores, potencia_inicial);

      while(1){
        if((SensorUS(Ultra_boneco_direito) <=10) || (SensorUS(Ultra_boneco_esquerdo) <=10)){
              Off(ambos_motores);
              Wait(1000);

              while((SensorUS(Ultra_boneco_direito) <=10) || (SensorUS(Ultra_boneco_esquerdo) <=10)){

              }
              }
          rotacao_direita = MotorRotationCount (motor_direito);   // Pega quantas voltas o motor direito deu
          rotacao_esquerda = MotorRotationCount (motor_esquerdo); // Pega quantas voltas o motor esquerdo deu

          erro_tragetoria = rotacao_direita - rotacao_esquerda;   // Erro nas rotações, idealmente deveria ser zero para que o robô ande reto
          termo_proporcional = kp * erro_tragetoria;

          historico_erro += erro_tragetoria;
          // Mantém o histórico de erros para fazer a parte integrativa do PID
          if(historico_erro > maximo_integrador){                 // Limita o histórico de erros dentro de um limite inferior e superior
              historico_erro = maximo_integrador;
          }else if(historico_erro < minimo_integrador){
              historico_erro = minimo_integrador;
          }
          termo_integrativo = ki * historico_erro;

          termo_derivativo = kd * (ultimo_erro - erro_tragetoria);
          ultimo_erro = erro_tragetoria;                            // Atualiza o erro passado

          correcao = termo_derivativo + termo_integrativo + termo_proporcional;  // Aqui vc deu todos os termos a correcao
          if(correcao != 0){
            OnFwd(motor_esquerdo, correcao + potencia_inicial);
            OnFwd(motor_direito, potencia_inicial);
          }else{
                OnFwd(motor_esquerdo,potencia_inicial);
                OnFwd(motor_direito, potencia_inicial);
                }
          }
}
