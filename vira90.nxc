#define r_roda 4.1 //raio da roda, em cm
#define d_rodas 16 //distãncia de uma roda a outra, em cm
#define motor_direito OUT_A
#define motor_esquerdo OUT_C
#define ambos_motores OUT_AC
#define Giroscopio IN_4
#define Ultra_boneco_direito IN_3
#define Ultra_boneco_esquerdo IN_2
//#define HT_1 IN_4 precisamos mudar isso para o escravo
#define esquerda 1
#define frente 2
#define direita 3
#define PRETO    1
#define AZUL     2
#define VERDE    3
#define AMARELO  4
#define VERMELHO 5
#define BRANCO   6
#define FORA     7
#define maximo_integrador 100   // Valor máximo para o estado integrativo
#define minimo_integrador -100  // Valor mínimo para o estado integrativo
#define potencia_inicial 60     // Valor de potencia inicial passada para o motor
#define kp 1  // Ganho proporcional
#define ki 0  // Ganho integrativo
#define kd 0  // Ganho derivativo
#define tamanho_da_rampa 100
#define distancia_do_boneco 15
#define distancia_chao 14

float erro_total_roda_esquerda = 0;
float erro_total_roda_direita = 0;

void vira90(int lado){
  float angle = 0, gyro = 0;
  unsigned long time, prev_time;
  time = CurrentTick();

  if(lado == direita){
    Off(ambos_motores);
    OnFwd(motor_esquerdo, 70);
    while(angle <= 90){
      prev_time = time;
      time = CurrentTick();
      gyro = SensorHTGyro(Giroscopio);
      angle += gyro * (time - prev_time)/1000.0;
    }
  }else if(lado == esquerda){
    Off(ambos_motores);
    OnFwd(motor_direito,70);
    while(angle >= -90){
      prev_time = time;
      time = CurrentTick();
      gyro = SensorHTGyro(Giroscopio);
      angle += gyro * (time - prev_time)/1000.0;
    }
  }
}

task main(){

  SetSensorLowspeed(Ultra_boneco_direito);
  SetSensorLowspeed(Ultra_boneco_esquerdo);
  SetSensorHTGyro(Giroscopio);

  float teste1, teste2 = 0;
  float rotacao_direita, rotacao_esquerda, correcao, erro_tragetoria, historico_erro = 0, ultimo_erro = 0;
	float termo_proporcional = 0, termo_integrativo = 0, termo_derivativo = 0;
  OnFwd(ambos_motores,potencia_inicial);

  while(1){
      if(SensorUS(Ultra_boneco_direito) <= 15){
        Off(ambos_motores);
        Wait(2000);
        teste1 = MotorRotationCount(motor_esquerdo);
        teste2 = MotorRotationCount(motor_esquerdo);
        while(teste1-teste2 < 300){
          teste2 = MotorRotationCount(motor_esquerdo);
          OnFwd(ambos_motores, -40);
        }
        vira90(direita);

      }else if(SensorUS(Ultra_boneco_esquerdo) <= 15){
        Off(ambos_motores);
        Wait(2000);
        teste1 = MotorRotationCount(motor_esquerdo);
        teste2 = MotorRotationCount(motor_esquerdo);
        while(teste1-teste2 < 300){
          teste2 = MotorRotationCount(motor_esquerdo);
          OnFwd(ambos_motores, -40);
        }
        vira90(esquerda);
      }


      OnFwd(ambos_motores, potencia_inicial);
    }
      /*rotacao_direita = MotorRotationCount (motor_direito) - erro_total_roda_direita;   // Pega quantas voltas o motor direito deu
      rotacao_esquerda = MotorRotationCount (motor_esquerdo) - erro_total_roda_esquerda; // Pega quantas voltas o motor esquerdo deu

  		erro_tragetoria = rotacao_direita - rotacao_esquerda;   // Erro nas rotações, idealmente deveria ser zero para que o robô ande reto
  		termo_proporcional = kp * erro_tragetoria;
  		historico_erro += erro_tragetoria; // Mantém o histórico de erros para fazer a parte integrativa do PID

  		if(historico_erro > maximo_integrador){                 // Limita o histórico de erros dentro de um limite inferior e superior
  				historico_erro = maximo_integrador;
  		}else if(historico_erro < minimo_integrador){
  				historico_erro = minimo_integrador;
  		}

  		termo_integrativo = ki * historico_erro;

  		termo_derivativo = kd * (ultimo_erro - erro_tragetoria);
  		ultimo_erro = erro_tragetoria;                            // Atualiza o erro passado

  		correcao = termo_derivativo + termo_integrativo + termo_proporcional;  // Aqui vc deu todos os termos a correcao
  		if(correcao != 0){
  			OnFwd(motor_esquerdo, correcao + potencia_inicial);
  			OnFwd(motor_direito, potencia_inicial);
  		}else{
  					OnFwd(motor_esquerdo,potencia_inicial);
  					OnFwd(motor_direito, potencia_inicial);
  					}
  		}*/
}
