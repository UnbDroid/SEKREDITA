#define BT_CONN 1
#define OUT_MBOX 1
#define IN_MBOX 5
#define Ultra_Boneco_Esquerda IN_1
#define Ultra_Boneco_Direita IN_2
#define Ultra_Boneco_Frente IN_3
#define PORTA_E OUT_A
#define PORTA_D OUT_C
#define RAMPA OUT_B
#define PORTAS OUT_AC
#define Distancia_do_Boneco 20
#define esquerda 1
#define frente 2
#define direita 3
#define PRETO    1
#define AZUL     2
#define VERDE    3
#define AMARELO  4
#define VERMELHO 5
#define BRANCO   6
#define FORA     7
#define alfa 0.8
sub BTCheck(int conn){
  if(!BluetoothStatus(conn)==NO_ERR){
    ClearScreen();
    TextOut(5,LCD_LINE2,"Erro");
    Wait(1000);
    Stop(true);
   }
}

int retorna_leitura_mediana(int lado){

	float leitura[5], max = 0;
	int i,j,indice;

	// Pega as 5 leituras
	for(i=0;i<=4;i++){
		if(lado == esquerda){
			leitura[i] = SensorUS(Ultra_Boneco_Esquerda);
		}else if(lado == direita){
			leitura[i] = SensorUS(Ultra_Boneco_Direita);
		}
	}

	// Ordenação do vetor de leituras
	for(i=0;i<=4;i++){
		for(j=0;j<=4-i;j++){
			if(leitura[j] > max){
				indice = j;
				max = leitura[j];
			}
		}
		if(indice != 4-i){
			max = leitura[indice];
			leitura[indice] = leitura[4-i];
			leitura[4-i] = max;
		}
		max = 0;
	}

	return leitura[2];
}

void pega_boneco(){
	int i=0;
	ClearScreen();
	TextOut(10,LCD_LINE1, "Esperando o Mestre");
	while(ReceiveRemoteNumber(IN_MBOX,true, i) == STAT_MSG_EMPTY_MAILBOX);

	while(SensorUS(Ultra_Boneco_Frente)>12){
		ClearScreen();
		TextOut(10,LCD_LINE1, "Indo para frente");
	}

	SendResponseNumber(OUT_MBOX, 2);
	while(MotorRotationCount(PORTA_D) > -90){
		OnFwd(PORTA_D, -60);
		OnFwd(PORTA_E, -55);
	}
	Off(PORTAS);
	while(MotorRotationCount(RAMPA) < 40){
		OnFwd(RAMPA, 40);
	}
	Wait(3000);
}

task main(){

	SetSensorLowspeed(Ultra_Boneco_Direita);
	SetSensorLowspeed(Ultra_Boneco_Frente);
	SetSensorLowspeed(Ultra_Boneco_Esquerda);

	int i=0;
	float media_e = 255,media_d = 255, leitura_e, leitura_d;
	BTCheck(0);

	while(ReceiveRemoteNumber(IN_MBOX,true,i) == STAT_MSG_EMPTY_MAILBOX); // Espera o mestre ativar o escravo


	do {
    // Pega as leituras
    leitura_e = retorna_leitura_mediana(esquerda);
    leitura_d = retorna_leitura_mediana(direita);

    // Calcula a média dos valores lidos
    media_e = alfa*leitura_e + (1-alfa)*media_e;
    media_d = alfa*leitura_d + (1-alfa)*media_d;

    ClearScreen();
	NumOut(4,LCD_LINE1, media_e);
	NumOut(4,LCD_LINE2, media_d);

	}	while(media_e > Distancia_do_Boneco && media_d > Distancia_do_Boneco);// PROCURA BONECO LATERAL


	if(media_d < Distancia_do_Boneco){ // Achou boneco na direita
		SendResponseNumber(OUT_MBOX, direita);
	}else if (media_e < Distancia_do_Boneco) {// Achou boneco na esquerda
		SendResponseNumber(OUT_MBOX, esquerda);
	}

	while(ReceiveRemoteNumber(IN_MBOX,true,i) == STAT_MSG_EMPTY_MAILBOX); // Recebe avisando que o mestre recebeu a mensagem

	while(MotorRotationCount(PORTA_D) < 80 && MotorRotationCount(PORTA_E) < 80){
		OnFwd(PORTAS, 50);
	}
	Off(PORTAS);

	OnRev(RAMPA, 20);
	Wait(200);

	Off(RAMPA);

	SendResponseNumber(OUT_MBOX, 1); // Fala pro mestre que abriu as portas

	while(SensorUS(Ultra_Boneco_Frente) > 17){
		ClearScreen();
		NumOut(0,LCD_LINE1,SensorUS(Ultra_Boneco_Frente));
	}

	SendResponseNumber(OUT_MBOX, 1); // Avisa pro mestre que achou algo no sensor do frente enquanto o robo ta girando

	while(SensorUS(Ultra_Boneco_Frente) > 11);

	SendResponseNumber(OUT_MBOX, 1); // Avisa que achou o boneco muito perto do sensor 

	while(ReceiveRemoteNumber(IN_MBOX,true,i) == STAT_MSG_EMPTY_MAILBOX); // Espera o mestre falar que parou



	OnRev(PORTAS, 60);
	Wait(300);
	Off(PORTAS);
	OnFwd(RAMPA, 60);


	Wait(10000);



	Stop(1);
	//pega_boneco();

}
